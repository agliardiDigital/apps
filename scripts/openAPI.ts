import { walk } from "std/fs/mod.ts";
import { dirname, join } from "std/path/mod.ts";
import { OpenAPIV3 } from "npm:openapi-types";
import {
  compile,
  Options as CompileOptions,
} from "npm:json-schema-to-typescript";

const BANNER_COMMENT = `
// DO NOT EDIT. This file is generated by deco.
// This file SHOULD be checked into source version control.
// To generate this file: deno run -A scripts/openAPI.ts

`;

const HTTP_VERBS = ["get", "post", "put", "delete", "patch", "head"] as const;

const COMPILE_OPTIONS: Partial<CompileOptions> = {
  bannerComment: "",
  unknownAny: true,
  additionalProperties: false,
  format: true,
};

const MEDIA_TYPE_JSON = "application/json";

const AUTOGEN_TYPE_NAME = "Autogen";

const isOpenAPIv3 = (x: any): x is OpenAPIV3.Document =>
  x?.openapi?.startsWith("3.");

const isReferenceObject = (x: any): x is OpenAPIV3.ReferenceObject => x?.$ref;

const allSpecPaths: string[] = [];

for await (const entry of walk(".")) {
  if (entry.isFile && entry.path.endsWith(".openapi.json")) {
    allSpecPaths.push(entry.path);
  }
}

const specsByModule = allSpecPaths.reduce(
  (acc, specPath) => {
    const dir = dirname(specPath);

    acc[dir] ||= [];
    acc[dir].push(specPath);

    return acc;
  },
  {} as Record<string, string[]>,
);

// transforms: /a/{b}/c => /a/:b/c
const toPathTemplate = (path: string) =>
  path.replace(/{/g, ":").replace(/}/g, "");

for (const [base, paths] of Object.entries(specsByModule)) {
  const outfile = join(base, "api.gen.ts");
  const types = [];

  console.info(`Generating API types for specs at ${base}`);
  for (const path of paths) {
    const document = JSON.parse(await Deno.readTextFile(path));

    if (!isOpenAPIv3(document)) {
      throw new Error("Only OpenAPI@3x is supported");
    }

    for (const [path, pathItem] of Object.entries(document.paths)) {
      const pathTemplate = toPathTemplate(path);

      for (const verb of HTTP_VERBS) {
        const item = pathItem?.[verb];

        if (!item) {
          continue;
        }

        const { parameters = [], requestBody, responses } = item;

        const searchParamsSchema = parameters
          .filter((x): x is OpenAPIV3.ParameterObject => !isReferenceObject(x))
          .filter((x) => x.in === "query")
          .reduce((schema, item) => {
            if (item.schema && !isReferenceObject(item.schema)) {
              schema.properties[item.name] = item.schema;
            }

            return schema;
          }, {
            type: "object" as const,
            properties: {} as Record<string, OpenAPIV3.SchemaObject>,
          });

        const bodySchema = !isReferenceObject(requestBody) &&
          requestBody?.content?.[MEDIA_TYPE_JSON]?.schema;

        const ok = responses?.["200"] || responses?.["201"] ||
          responses?.["206"];
        const responseSchema = !isReferenceObject(ok) &&
          ok?.content?.[MEDIA_TYPE_JSON].schema;

        const searchParams =
          Object.keys(searchParamsSchema.properties).length > 0
            ? await compile(
              searchParamsSchema,
              AUTOGEN_TYPE_NAME,
              COMPILE_OPTIONS,
            )
            : null;

        const body = bodySchema
          ? await compile(bodySchema, AUTOGEN_TYPE_NAME, COMPILE_OPTIONS)
          : null;

        const response = responseSchema
          ? await compile(responseSchema, AUTOGEN_TYPE_NAME, COMPILE_OPTIONS)
          : null;

        const typed = `"${verb.toUpperCase()} ${pathTemplate}": {
          ${
          Object.entries({ searchParams, body, response })
            .filter((e) => Boolean(e[1]))
            .map(([key, value]) =>
              `${key}: ${
                value!.replace(`export interface ${AUTOGEN_TYPE_NAME}`, "")
                  .replace(`export type ${AUTOGEN_TYPE_NAME} = `, "")
              }`
            )
        }
        }`;

        types.push(typed);
      }
    }
  }

  await Deno.writeTextFile(
    outfile,
    `${BANNER_COMMENT}export interface API {\n${types.join("\n")}\n}`,
  );

  // Format using deno
  const fmt = new Deno.Command(Deno.execPath(), { args: ["fmt", outfile] });
  await fmt.output();
}
